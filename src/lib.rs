use std::collections::BTreeMap;
use std::io::{BufWriter, Write};
use std::{fs::File, path::Path};
pub mod wgsl;

// TODO: Simplify these templates and indentation?
// TODO: Structure the code to make it easier to imagine what the output will look like.
pub fn write_module_file(file_path: &str, wgsl_path: &str, wgsl_include_path: &str) {
    let file_path = Path::new(file_path);
    std::fs::create_dir_all(file_path.parent().unwrap()).unwrap();

    let wgsl_source = std::fs::read_to_string(wgsl_path).unwrap();
    let module = naga::front::wgsl::parse_str(&wgsl_source).unwrap();
    let bind_group_data = wgsl::get_bind_group_data(&module);

    let mut f = BufWriter::new(File::create(file_path).unwrap());
    writeln!(&mut f, "// File automatically generated by build.rs.").unwrap();
    writeln!(&mut f, "// Changes made to this file will not be saved.").unwrap();

    write_bind_groups_module(&mut f, &bind_group_data);
    write_vertex_module(&mut f, &module);

    writeln!(
        f,
        "pub fn create_shader_module(device: &wgpu::Device) -> wgpu::ShaderModule {{"
    )
    .unwrap();
    writeln!(
        f,
        "    device.create_shader_module(&wgpu::ShaderModuleDescriptor {{"
    )
    .unwrap();
    writeln!(f, "        label: None,").unwrap();
    writeln!(f, "        source: wgpu::ShaderSource::Wgsl(std::borrow::Cow::Borrowed(include_str!(\"{wgsl_include_path}\")))").unwrap();
    writeln!(f, "    }})").unwrap();
    writeln!(f, "}}").unwrap();

    writeln!(
        f,
        "pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {{"
    )
    .unwrap();
    writeln!(
        f,
        "    device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {{"
    )
    .unwrap();
    writeln!(f, "        label: None,").unwrap();
    writeln!(f, "        bind_group_layouts: &[").unwrap();
    for (group_no, _) in &bind_group_data {
        writeln!(
            f,
            "            &bind_groups::BindGroup{group_no}::get_bind_group_layout(&device),"
        )
        .unwrap();
    }
    writeln!(f, "        ],").unwrap();
    writeln!(f, "        push_constant_ranges: &[],").unwrap();
    writeln!(f, "    }})").unwrap();
    writeln!(f, "}}").unwrap();
}

fn write_vertex_module<W: Write>(f: &mut W, module: &naga::Module) {
    writeln!(f, "pub mod vertex {{").unwrap();
    for (name, location) in wgsl::get_vertex_input_locations(&module) {
        // TODO: Use const case
        let const_name = name.to_uppercase();
        writeln!(f, "    pub const {const_name}_LOCATION: u32 = {location}u32;").unwrap();
    }
    writeln!(f, "}}").unwrap();
}

// TODO: Take an iterator instead?
fn write_bind_groups_module<W: Write>(f: &mut W, bind_group_data: &BTreeMap<u32, wgsl::GroupData>) {
    writeln!(f, "pub mod bind_groups {{").unwrap();
    for (group_no, group) in bind_group_data {
        writeln!(f, "    pub struct BindGroup{group_no}(wgpu::BindGroup);").unwrap();

        write_bind_group_layout(f, *group_no, &group);
        write_bind_group_layout_descriptor(f, *group_no, &group);
        impl_bind_group(f, *group_no, &group);
    }

    writeln!(f, "    pub struct BindGroups<'a> {{").unwrap();
    for (group_no, _) in bind_group_data {
        writeln!(
            f,
            "        pub bind_group{group_no}: &'a BindGroup{group_no},"
        )
        .unwrap();
    }
    writeln!(f, "    }}").unwrap();

    writeln!(f, "    pub fn set_bind_groups<'a>(").unwrap();
    writeln!(f, "        render_pass: &mut wgpu::RenderPass<'a>,").unwrap();
    writeln!(f, "        bind_groups: BindGroups<'a>,").unwrap();
    writeln!(f, "    ) {{").unwrap();
    for (group_no, _) in bind_group_data {
        writeln!(
            f,
            "        render_pass.set_bind_group({group_no}u32, &bind_groups.bind_group{group_no}.0, &[]);"
        )
        .unwrap();
    }
    writeln!(f, "    }}").unwrap();

    writeln!(f, "}}").unwrap();
}

fn write_bind_group_layout<W: Write>(f: &mut W, group_no: u32, group: &wgsl::GroupData) {
    writeln!(f, "    pub struct BindGroupLayout{group_no}<'a> {{").unwrap();
    for binding in &group.bindings {
        let field_name = binding.name.as_ref().unwrap();
        // TODO: Support more types.
        let field_type = match binding.inner_type {
            // TODO: Is it possible to make structs strongly typed and handle buffer creation automatically?
            // This could be its own module and associated tests.
            naga::TypeInner::Struct { .. } => "wgpu::Buffer",
            naga::TypeInner::Image { .. } => "wgpu::TextureView",
            naga::TypeInner::Sampler { .. } => "wgpu::Sampler",
            _ => panic!("Unsupported type for binding fields."),
        };

        writeln!(f, "        pub {field_name}: &'a {field_type},").unwrap();
    }
    writeln!(f, "    }}").unwrap();
}

fn write_bind_group_layout_descriptor<W: Write>(f: &mut W, group_no: u32, group: &wgsl::GroupData) {
    writeln!(
        f,
        "    const LAYOUT_DESCRIPTOR{group_no}: wgpu::BindGroupLayoutDescriptor ="
    )
    .unwrap();
    writeln!(f, "        wgpu::BindGroupLayoutDescriptor {{").unwrap();
    writeln!(f, "            label: None,").unwrap();
    writeln!(f, "            entries: &[").unwrap();

    for binding in &group.bindings {
        // TODO: Support more types.
        let binding_type = match binding.inner_type {
            naga::TypeInner::Struct { .. } => {
                "wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    }"
            }
            naga::TypeInner::Image { .. } => {
                // TODO: Don't assume the dimensions.
                "wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    }"
            }
            naga::TypeInner::Sampler { .. } => {
                // TODO: Don't assume filtering?
                "wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering)"
            }
            // TODO: Better error handling.
            _ => panic!("Failed to generate BindingType."),
        };

        let binding_index = binding.binding_index;

        writeln!(f, "                wgpu::BindGroupLayoutEntry {{").unwrap();
        writeln!(f, "                    binding: {binding_index}u32,").unwrap();
        writeln!(
            f,
            "                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,"
        )
        .unwrap();
        writeln!(f, "                    ty: {binding_type},").unwrap();
        writeln!(f, "                    count: None,").unwrap();
        writeln!(f, "                }},").unwrap();
    }
    writeln!(f, "            ]").unwrap();

    writeln!(f, "        }};").unwrap();
}

fn impl_bind_group<W: Write>(f: &mut W, group_no: u32, group: &wgsl::GroupData) {
    writeln!(f, "    impl BindGroup{group_no} {{").unwrap();
    writeln!(
        f,
        "        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {{"
    )
    .unwrap();
    writeln!(
        f,
        "            device.create_bind_group_layout(&LAYOUT_DESCRIPTOR{group_no})"
    )
    .unwrap();
    writeln!(f, "        }}").unwrap();

    writeln!(f, "        pub fn from_bindings(device: &wgpu::Device, bindings: BindGroupLayout{group_no}) -> Self {{").unwrap();
    writeln!(f, "            let bind_group_layout = device.create_bind_group_layout(&LAYOUT_DESCRIPTOR{group_no});").unwrap();
    writeln!(
        f,
        "            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {{"
    )
    .unwrap();
    writeln!(f, "                layout: &bind_group_layout,").unwrap();
    writeln!(f, "                entries: &[").unwrap();
    for binding in &group.bindings {
        let binding_index = binding.binding_index;
        let binding_name = binding.name.as_ref().unwrap();
        let resource_type = match binding.inner_type {
            naga::TypeInner::Struct { .. } => {
                // TODO: Don't assume the entire buffer is used.
                format!("bindings.{binding_name}.as_entire_binding()")
            }
            naga::TypeInner::Image { .. } => {
                format!("wgpu::BindingResource::TextureView(bindings.{binding_name})")
            }
            naga::TypeInner::Sampler { .. } => {
                format!("wgpu::BindingResource::Sampler(bindings.{binding_name})")
            }
            // TODO: Better error handling.
            _ => panic!("Failed to generate BindingType."),
        };

        writeln!(f, "                    wgpu::BindGroupEntry {{").unwrap();
        writeln!(f, "                        binding: {binding_index}u32,").unwrap();
        writeln!(f, "                        resource: {resource_type},").unwrap();
        writeln!(f, "                    }},").unwrap();
    }
    writeln!(f, "                ],").unwrap();
    writeln!(f, "                label: None,").unwrap();
    writeln!(f, "            }});").unwrap();
    writeln!(f, "            Self(bind_group)").unwrap();
    writeln!(f, "        }}").unwrap();

    writeln!(
        f,
        "        pub fn set<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {{"
    )
    .unwrap();
    writeln!(
        f,
        "            render_pass.set_bind_group({group_no}u32, &self.0, &[]);"
    )
    .unwrap();
    writeln!(f, "        }}").unwrap();

    writeln!(f, "    }}").unwrap();
}
