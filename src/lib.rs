use std::collections::BTreeMap;
use std::io::{BufWriter, Write};
use std::{fs::File, path::Path};
pub mod wgsl;
use indoc::{indoc, writedoc};

// TODO: Simplify these templates and indentation?
// TODO: Structure the code to make it easier to imagine what the output will look like.
// TODO: Create a function that indents each line of indoc! output?
pub fn write_module_file(file_path: &str, wgsl_path: &str, wgsl_include_path: &str) {
    let file_path = Path::new(file_path);
    std::fs::create_dir_all(file_path.parent().unwrap()).unwrap();

    let wgsl_source = std::fs::read_to_string(wgsl_path).unwrap();
    let module = naga::front::wgsl::parse_str(&wgsl_source).unwrap();
    let bind_group_data = wgsl::get_bind_group_data(&module);

    let mut f = BufWriter::new(File::create(file_path).unwrap());
    writeln!(&mut f, "// File automatically generated by build.rs.").unwrap();
    writeln!(&mut f, "// Changes made to this file will not be saved.").unwrap();

    // TODO: Avoid having a dependency on naga here.
    write_bind_groups_module(&mut f, &bind_group_data, &module);
    write_vertex_module(&mut f, &module);

    writedoc!(
        f,
        r#"
            pub fn create_shader_module(device: &wgpu::Device) -> wgpu::ShaderModule {{
                device.create_shader_module(&wgpu::ShaderModuleDescriptor {{
                    label: None,
                    source: wgpu::ShaderSource::Wgsl(std::borrow::Cow::Borrowed(include_str!("{wgsl_include_path}")))
                }})
            }}
        "#
    )
    .unwrap();

    // TODO: Find a cleaner way of doing this?
    let bind_group_layouts = bind_group_data
        .iter()
        .map(|(group_no, _)| {
            format!("&bind_groups::BindGroup{group_no}::get_bind_group_layout(&device),")
        })
        .collect::<Vec<String>>()
        .join("\n            ");

    writedoc!(
        f,
        r#"
            pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {{
                device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {{
                    label: None,
                    bind_group_layouts: &[
                        {bind_group_layouts}
                    ],
                    push_constant_ranges: &[],
                }})
            }}
        "#
    )
    .unwrap();
}

fn write_vertex_module<W: Write>(f: &mut W, module: &naga::Module) {
    writeln!(f, "pub mod vertex {{").unwrap();
    for (name, location) in wgsl::get_vertex_input_locations(&module) {
        // TODO: Use const case
        let const_name = name.to_uppercase();
        writeln!(
            f,
            "    pub const {const_name}_LOCATION: u32 = {location}u32;"
        )
        .unwrap();
    }
    writeln!(f, "}}").unwrap();
}

// TODO: Take an iterator instead?
fn write_bind_groups_module<W: Write>(
    f: &mut W,
    bind_group_data: &BTreeMap<u32, wgsl::GroupData>,
    module: &naga::Module,
) {
    writeln!(f, "pub mod bind_groups {{").unwrap();
    for (group_no, group) in bind_group_data {
        writeln!(f, "    pub struct BindGroup{group_no}(wgpu::BindGroup);").unwrap();

        write_bind_group_layout(f, *group_no, &group);
        write_bind_group_layout_descriptor(f, *group_no, &group);
        impl_bind_group(f, *group_no, &group);

        write_structs(f, *group_no, &group, &module);
    }

    writeln!(f, "    pub struct BindGroups<'a> {{").unwrap();
    for (group_no, _) in bind_group_data {
        writeln!(
            f,
            "        pub bind_group{group_no}: &'a BindGroup{group_no},"
        )
        .unwrap();
    }
    writeln!(f, "    }}").unwrap();

    writeln!(f, "    pub fn set_bind_groups<'a>(").unwrap();
    writeln!(f, "        render_pass: &mut wgpu::RenderPass<'a>,").unwrap();
    writeln!(f, "        bind_groups: BindGroups<'a>,").unwrap();
    writeln!(f, "    ) {{").unwrap();
    for (group_no, _) in bind_group_data {
        writeln!(
            f,
            "        render_pass.set_bind_group({group_no}u32, &bind_groups.bind_group{group_no}.0, &[]);"
        )
        .unwrap();
    }
    writeln!(f, "    }}").unwrap();

    writeln!(f, "}}").unwrap();
}

fn write_structs<W: Write>(
    f: &mut W,
    group_no: u32,
    group: &wgsl::GroupData,
    module: &naga::Module,
) {
    // Create matching Rust structs for WGSL structs.
    // The goal is to eventually have safe ways to initialize uniform buffers.

    // TODO: Move this into the WGSL module and test this?
    // TODO: How to provide a convenient way to work with these types.
    // Users will want to either a) create a new buffer each type or b) reuse an existing buffer.
    // It might not make sense from a performance perspective to constantly create new resources.
    // This requires the user to keep track of the buffer separately from the BindGroup itself.
    for binding in &group.bindings {
        match &binding.binding_type.inner {
            naga::TypeInner::Struct { members, .. } => {
                let name = binding.binding_type.name.as_ref().unwrap();
                writeln!(f, "    #[repr(C)]").unwrap();
                writeln!(
                    f,
                    "    #[derive(Debug, Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]"
                )
                .unwrap();
                writeln!(f, "    pub struct {name} {{").unwrap();
                for member in members {
                    let member_name = member.name.as_ref().unwrap();
                    let member_type = wgsl::rust_type(&module, &module.types[member.ty]);
                    writeln!(f, "        pub {member_name}: {member_type},").unwrap();
                }
                writeln!(f, "    }}").unwrap();
            }
            _ => (),
        }
    }
}

fn write_bind_group_layout<W: Write>(f: &mut W, group_no: u32, group: &wgsl::GroupData) {
    writeln!(f, "    pub struct BindGroupLayout{group_no}<'a> {{").unwrap();
    for binding in &group.bindings {
        let field_name = binding.name.as_ref().unwrap();
        // TODO: Support more types.
        let field_type = match binding.binding_type.inner {
            // TODO: Is it possible to make structs strongly typed and handle buffer creation automatically?
            // This could be its own module and associated tests.
            naga::TypeInner::Struct { .. } => "wgpu::Buffer",
            naga::TypeInner::Image { .. } => "wgpu::TextureView",
            naga::TypeInner::Sampler { .. } => "wgpu::Sampler",
            _ => panic!("Unsupported type for binding fields."),
        };

        writeln!(f, "        pub {field_name}: &'a {field_type},").unwrap();
    }
    writeln!(f, "    }}").unwrap();
}

fn write_bind_group_layout_descriptor<W: Write>(f: &mut W, group_no: u32, group: &wgsl::GroupData) {
    writeln!(
        f,
        "    const LAYOUT_DESCRIPTOR{group_no}: wgpu::BindGroupLayoutDescriptor ="
    )
    .unwrap();
    writeln!(f, "        wgpu::BindGroupLayoutDescriptor {{").unwrap();
    writeln!(f, "            label: None,").unwrap();
    writeln!(f, "            entries: &[").unwrap();

    for binding in &group.bindings {
        // TODO: Support more types.
        let binding_type = match binding.binding_type.inner {
            naga::TypeInner::Struct { .. } => {
                "wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    }".to_string()
            }
            naga::TypeInner::Image { dim, .. } => {
                // TODO: Don't assume the dimensions.
                let view_dim = match dim {
                    naga::ImageDimension::D1 => "wgpu::TextureViewDimension::D1",
                    naga::ImageDimension::D2 => "wgpu::TextureViewDimension::D2",
                    naga::ImageDimension::D3 => "wgpu::TextureViewDimension::D3",
                    naga::ImageDimension::Cube => "wgpu::TextureViewDimension::Cube",
                };

                format!("wgpu::BindingType::Texture {{
                        multisampled: false,
                        view_dimension: {view_dim},
                        sample_type: wgpu::TextureSampleType::Float {{ filterable: true }},
                    }}")
            }
            naga::TypeInner::Sampler { .. } => {
                // TODO: Don't assume filtering?
                "wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering)".to_string()
            }
            // TODO: Better error handling.
            _ => panic!("Failed to generate BindingType."),
        };

        let binding_index = binding.binding_index;

        writeln!(f, "                wgpu::BindGroupLayoutEntry {{").unwrap();
        writeln!(f, "                    binding: {binding_index}u32,").unwrap();
        writeln!(
            f,
            "                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,"
        )
        .unwrap();
        writeln!(f, "                    ty: {binding_type},").unwrap();
        writeln!(f, "                    count: None,").unwrap();
        writeln!(f, "                }},").unwrap();
    }
    writeln!(f, "            ]").unwrap();

    writeln!(f, "        }};").unwrap();
}

fn impl_bind_group<W: Write>(f: &mut W, group_no: u32, group: &wgsl::GroupData) {
    writeln!(f, "    impl BindGroup{group_no} {{").unwrap();
    writeln!(
        f,
        "        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {{"
    )
    .unwrap();
    writeln!(
        f,
        "            device.create_bind_group_layout(&LAYOUT_DESCRIPTOR{group_no})"
    )
    .unwrap();
    writeln!(f, "        }}").unwrap();

    writeln!(f, "        pub fn from_bindings(device: &wgpu::Device, bindings: BindGroupLayout{group_no}) -> Self {{").unwrap();
    writeln!(f, "            let bind_group_layout = device.create_bind_group_layout(&LAYOUT_DESCRIPTOR{group_no});").unwrap();
    writeln!(
        f,
        "            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {{"
    )
    .unwrap();
    writeln!(f, "                layout: &bind_group_layout,").unwrap();
    writeln!(f, "                entries: &[").unwrap();
    for binding in &group.bindings {
        let binding_index = binding.binding_index;
        let binding_name = binding.name.as_ref().unwrap();
        let resource_type = match binding.binding_type.inner {
            naga::TypeInner::Struct { .. } => {
                // TODO: Don't assume the entire buffer is used.
                format!("bindings.{binding_name}.as_entire_binding()")
            }
            naga::TypeInner::Image { .. } => {
                format!("wgpu::BindingResource::TextureView(bindings.{binding_name})")
            }
            naga::TypeInner::Sampler { .. } => {
                format!("wgpu::BindingResource::Sampler(bindings.{binding_name})")
            }
            // TODO: Better error handling.
            _ => panic!("Failed to generate BindingType."),
        };

        writeln!(f, "                    wgpu::BindGroupEntry {{").unwrap();
        writeln!(f, "                        binding: {binding_index}u32,").unwrap();
        writeln!(f, "                        resource: {resource_type},").unwrap();
        writeln!(f, "                    }},").unwrap();
    }
    writeln!(f, "                ],").unwrap();
    writeln!(f, "                label: None,").unwrap();
    writeln!(f, "            }});").unwrap();
    writeln!(f, "            Self(bind_group)").unwrap();
    writeln!(f, "        }}").unwrap();

    writeln!(
        f,
        "        pub fn set<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {{"
    )
    .unwrap();
    writeln!(
        f,
        "            render_pass.set_bind_group({group_no}u32, &self.0, &[]);"
    )
    .unwrap();
    writeln!(f, "        }}").unwrap();

    writeln!(f, "    }}").unwrap();
}
